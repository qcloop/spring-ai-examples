///usr/bin/env jbang "$0" "$@" ; exit $?
//DEPS org.zeroturnaround:zt-exec:1.12
//DEPS com.fasterxml.jackson.core:jackson-databind:2.17.1
//JAVA 17
//FILES ExampleInfo.json

/*
 * Integration test launcher for routing-workflow
 * Generated by scaffold_integration_test.py on 2025-08-01 11:48:19
 */

import com.fasterxml.jackson.databind.*;
import org.zeroturnaround.exec.*;
import java.nio.file.*;
import java.util.concurrent.TimeUnit;
import static java.lang.System.*;

record ExampleInfo(
    int timeoutSec, 
    String[] successRegex, 
    String[] requiredEnv,
    String[] setupCommands,
    String[] cleanupCommands
) {}

public class RunRoutingWorkflow {
    
    public static void main(String... args) throws Exception {
        Path configPath = Path.of("integration-tests/ExampleInfo.json");
        ExampleInfo cfg = new ObjectMapper().readValue(configPath.toFile(), ExampleInfo.class);

        // Verify required environment variables
        for (String envVar : cfg.requiredEnv()) {
            if (getenv(envVar) == null) {
                err.println("‚ùå Missing required environment variable: " + envVar);
                exit(1);
            }
        }

        try {
            
            // Build and run the main application
            out.println("üèóÔ∏è  Building routing-workflow...");
            runCommand(new String[]{"./mvnw", "clean", "package", "-q", "-DskipTests"}, 300);

            // Run setup commands AFTER build to avoid clean removing test files
            if (cfg.setupCommands() != null) {
                for (String setupCmd : cfg.setupCommands()) {
                    out.println("üîß Running setup: " + setupCmd);
                    runCommand(setupCmd.split("\\s+"), 60); // 1 minute timeout for setup
                }
            }

            out.println("üöÄ Running routing-workflow...");
            // Create persistent log file for debugging
            Path logDir = Paths.get("../../integration-testing/logs/integration-tests");
            Files.createDirectories(logDir);
            Path logFile = logDir.resolve("routing-workflow-spring-boot-" + System.currentTimeMillis() + ".log");
            
            ProcessResult result = new ProcessExecutor()
                .command("./mvnw", "spring-boot:run", "-q")
                .timeout(cfg.timeoutSec(), TimeUnit.SECONDS)
                .redirectOutput(Files.newOutputStream(logFile))
                .redirectErrorStream(true)
                .execute();
            
            int exitCode = result.getExitValue();

            // Verify output patterns
            String output = Files.readString(logFile);
            out.println("‚úÖ Verifying output patterns...");
            
            int failedPatterns = 0;
            for (String pattern : cfg.successRegex()) {
                if (output.matches("(?s).*" + pattern + ".*")) {
                    out.println("  ‚úì Found: " + pattern);
                } else {
                    err.println("  ‚ùå Missing: " + pattern);
                    failedPatterns++;
                }
            }

            // Display captured application output for debugging
            out.println("\nüìã Captured Application Output:");
            out.println("=== ROUTING WORKFLOW OUTPUT ===");
            
            // Extract and display ticket processing sections
            String[] lines = output.split("\n");
            boolean inTicketSection = false;
            
            for (String line : lines) {
                if (line.startsWith("Ticket ")) {
                    inTicketSection = true;
                    out.println("\n" + line);
                } else if (line.contains("Available routes:")) {
                    out.println(line);
                } else if (line.contains("Routing Analysis:")) {
                    out.println(line);
                } else if (line.contains("Selected route:")) {
                    out.println(line);
                } else if (line.contains("Support Response:")) {
                    out.println(line);
                } else if (inTicketSection && line.trim().isEmpty()) {
                    inTicketSection = false;
                } else if (inTicketSection || line.contains("Subject:") || line.contains("Message:")) {
                    out.println(line);
                }
            }

            // Keep log file for debugging - DO NOT DELETE
            out.println("\nüìÅ Spring Boot log preserved: " + logFile.toAbsolutePath());

            if (exitCode != 0) {
                err.println("‚ùå Application exited with code: " + exitCode);
                exit(exitCode);
            }

            if (failedPatterns > 0) {
                err.println("‚ùå Failed pattern verification: " + failedPatterns + " patterns missing");
                exit(1);
            }

            out.println("üéâ Integration test completed successfully!");

        } finally {
            // Run cleanup commands if specified
            if (cfg.cleanupCommands() != null) {
                for (String cleanupCmd : cfg.cleanupCommands()) {
                    out.println("üßπ Running cleanup: " + cleanupCmd);
                    try {
                        runCommand(cleanupCmd.split("\\s+"), 30);
                    } catch (Exception e) {
                        err.println("‚ö†Ô∏è  Cleanup command failed (non-fatal): " + e.getMessage());
                    }
                }
            }
        }
    }

    private static void runCommand(String[] cmd, int timeoutSec) throws Exception {
        ProcessResult result = new ProcessExecutor()
            .command(cmd)
            .timeout(timeoutSec, TimeUnit.SECONDS)
            .redirectOutput(System.out)
            .redirectError(System.err)
            .execute();
            
        int exit = result.getExitValue();
        if (exit != 0) {
            throw new RuntimeException("Command failed with exit code " + exit + ": " + String.join(" ", cmd));
        }
    }
}