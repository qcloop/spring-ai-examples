///usr/bin/env jbang "$0" "$@" ; exit $?
//DEPS org.zeroturnaround:zt-exec:1.12
//DEPS com.fasterxml.jackson.core:jackson-databind:2.17.1
//DEPS org.apache.httpcomponents.client5:httpclient5:5.2.1
//JAVA 17
//FILES ExampleInfo.json

/*
 * Integration test launcher for openai-streaming-response
 * Generated by scaffold_integration_test.py on 2025-07-31 01:10:23
 */

import com.fasterxml.jackson.databind.*;
import org.zeroturnaround.exec.*;
import org.apache.hc.client5.http.classic.methods.HttpGet;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.http.io.entity.EntityUtils;
import java.nio.file.*;
import java.util.concurrent.TimeUnit;
import java.net.*;
import java.net.URLEncoder;
import static java.lang.System.*;

record ExampleInfo(
    int timeoutSec, 
    String[] successRegex, 
    String[] requiredEnv,
    String[] setupCommands,
    String[] cleanupCommands
) {}

public class RunOpenaiStreamingResponse {
    
    public static void main(String... args) throws Exception {
        Path configPath = Path.of("integration-tests/ExampleInfo.json");
        ExampleInfo cfg = new ObjectMapper().readValue(configPath.toFile(), ExampleInfo.class);

        // Verify required environment variables
        for (String envVar : cfg.requiredEnv()) {
            if (getenv(envVar) == null) {
                err.println("‚ùå Missing required environment variable: " + envVar);
                exit(1);
            }
        }

        Process serverProcess = null;
        try {
            // Build the application
            out.println("üèóÔ∏è  Building openai-streaming-response...");
            runCommand(new String[]{"./mvnw", "clean", "package", "-q", "-DskipTests"}, 300);

            // Start the server in background
            out.println("üöÄ Starting web server...");
            // Create persistent log file for debugging
            Path logDir = Paths.get("../../integration-testing/logs/integration-tests");
            Files.createDirectories(logDir);
            Path logFile = logDir.resolve("openai-streaming-response-server-" + System.currentTimeMillis() + ".log");
            
            ProcessBuilder pb = new ProcessBuilder("./mvnw", "spring-boot:run", "-q");
            pb.redirectOutput(logFile.toFile());
            pb.redirectErrorStream(true);
            serverProcess = pb.start();

            // Wait for server to be ready
            out.println("‚è≥ Waiting for server to start...");
            int port = 8080;
            waitForServerReady(port, 60);
            
            // Test the streaming endpoint
            out.println("üß™ Testing streaming endpoint...");
            String response = testStreamingEndpoint(port);
            
            // Verify response patterns
            out.println("‚úÖ Verifying response patterns...");
            int failedPatterns = 0;
            for (String pattern : cfg.successRegex()) {
                if (response.matches("(?s).*" + pattern + ".*")) {
                    out.println("  ‚úì Found: " + pattern);
                } else {
                    err.println("  ‚ùå Missing: " + pattern);
                    failedPatterns++;
                }
            }

            if (failedPatterns > 0) {
                err.println("‚ùå Failed pattern verification: " + failedPatterns + " patterns missing");
                err.println("Full response: " + response);
                exit(1);
            }

            // Keep log file for debugging - DO NOT DELETE
            out.println("üìÅ Server log preserved: " + logFile.toAbsolutePath());
            out.println("üéâ Web application integration test completed successfully!");

        } finally {
            if (serverProcess != null) {
                out.println("üõë Shutting down server...");
                serverProcess.destroyForcibly();
                serverProcess.waitFor(10, TimeUnit.SECONDS);
            }
        }
    }

    private static void runCommand(String[] cmd, int timeoutSec) throws Exception {
        ProcessResult result = new ProcessExecutor()
            .command(cmd)
            .timeout(timeoutSec, TimeUnit.SECONDS)
            .redirectOutput(System.out)
            .redirectError(System.err)
            .execute();
            
        int exit = result.getExitValue();
        if (exit != 0) {
            throw new RuntimeException("Command failed with exit code " + exit + ": " + String.join(" ", cmd));
        }
    }

    private static void waitForServerReady(int port, int timeoutSec) throws Exception {
        long start = System.currentTimeMillis();
        long timeout = timeoutSec * 1000L;
        
        while (System.currentTimeMillis() - start < timeout) {
            try (Socket socket = new Socket()) {
                socket.connect(new InetSocketAddress("localhost", port), 1000);
                out.println("‚úÖ Server is ready on port " + port);
                return;
            } catch (Exception e) {
                Thread.sleep(1000);
            }
        }
        throw new RuntimeException("Server failed to start within " + timeoutSec + " seconds");
    }

    private static String testStreamingEndpoint(int port) throws Exception {
        String message = URLEncoder.encode("Tell me a joke", "UTF-8");
        String url = "http://localhost:" + port + "/ai/generateStream?message=" + message;
        
        try (CloseableHttpClient client = HttpClients.createDefault()) {
            HttpGet request = new HttpGet(url);
            request.setHeader("Accept", "text/event-stream");
            
            return client.execute(request, response -> {
                int status = response.getCode();
                if (status >= 200 && status < 300) {
                    String body = EntityUtils.toString(response.getEntity());
                    out.println("üì° Received streaming response (" + body.length() + " chars)");
                    return body;
                } else {
                    throw new RuntimeException("HTTP " + status + ": Failed to get streaming response");
                }
            });
        }
    }
}